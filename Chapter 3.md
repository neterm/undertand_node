# 异步 I/O

---

“异步”这个名词其实很早就诞生了，但它的大规模流行确实在 Web 2.0 浪潮中，它伴随着 Ajax 的第一个 A(Asnchronous)席卷了 Web。Node 在出现之前，最习惯异步编程的程序员莫过于前端工程师了。前端编程算 GUI 编程的一种，其中充斥着各种 Ajax 和事件，这些都是典型的异步应用场景。

但事实上，异步早就存在于操作系统的底层。在底层系统中，异步通信信号量、消息等方式有了广泛的应用。意外的是，在绝大多数高级编程语言中，异步并不多见，疑似呗屏蔽了一般。造成这个现象的主要原因也许令人经验：程序员不太适合通过异步来进行程序设计。

PHP 这门语言的设计最能体现这个观点。它对调用层不仅屏蔽了异步，甚至连多线程都不提供。PHP 语言从头到脚都是以同步阻塞的方式来执行的。它的优点十分明显，利于程序员顺序编写业务逻辑；它的缺点在小规模站点中基本不存在，但是在复杂的网络应用中，阻塞导致它无法更好地开发。

而在其它语言中，尽管可能存在异步的 API，它们构成 Node 的基调，Ryan Dahl 正是基于这几个因素设计了 Node。Ryan Dahl 最初期望设计出一个高性能的 Web 服务器，后来则演变为一个可以基于它构建各种告诉、可伸缩网络应用的平台，因为一个 Web 服务器已经无法完全涵盖和代表它的能力。尽管它不再是一个服务器，但是可以基于它搭建更多更丰富、更强大的网络应用。

与 Node 的事件驱动、异步 I/O 设计理念比较相近的一个知名产品为 Nginx。Nginx 采用纯 C 编写，性能表现非常优异。它们的区别在于，Nginx 具备面向客户端管理连接的强大能力，但是它背后依旧受限于各种同步方式的编程语言。但 Node 确实全方位的，既可以作为服务器端去处理客户端带来的大量并发请求，也能作为客户端向网络中的各个应用进行并发请求。

Web 的含义是网，Node 的表现就如同它的名字一样，在网络中灵活的一个节点。

## 3.1 为什么要异步 I/O

关于异步 I/O 为何在 Node 里如此重要，这与 Node 面向网络而设计不无关系。Web 应用已经不单是单台服务器能胜任的时代了，在跨网络的结构下，并发已经是现代编程中的标准配置了。具体到实处，则可以从用户体验和资源分配这两个方面说起。

### 3.1.1 用户体验

异步的概念之所以首先在 Web 2.0 中火起来，是因为在浏览器中 JavaScript 在单线程上执行，而且它还与 UI 渲染共用一个线程。这意味着 JavaScript 在执行的时候 UI 渲染和响应式处于停滞状态的。《高性能 JavaScript》一书中曾经总结过，如果脚本的执行时间超过 100ms，用户就会感到页面卡顿，以为网页停止响应。在 B/S 模型中，网络速度的限制给网页的实时体验造成很大的麻烦。如果网页临时需要获取一个网络资源，通过同步的方式获取，那么 JavaScript 则需要等待资源完全从服务器端获取后才能继续执行，这期间 UI 将停顿，不响应用户的交互行为。可以想象，这样的用户体验会有多差。而采用异步请求，在下载资源期间，JavaScript 和 UI 的执行都不会处于等待状态，可以继续响应用户的交互行为，给用户一个鲜活的页面。

同理，前端通过异步可以消除 UI 阻塞的现象，但是前端获取资源的速度也取决于后端的响应速度。假如一个资源来自于两个不同位置的数据返回，那么第一个资源需要 Mms 的耗时，第二个资源需要 Nms 的耗时，采用同步的方式，代码大致如下：

```js
// 消费时间M
getData('from_db');
// 消费时间N
getData('from_remote_api');
```

但是如果采用异步方式，第一个资源的获取并不会阻塞第二个资源，也即第二个资源的请求并不依赖第一个资源的结束。因此，我们可以享受并发的优势，相关代码如下：

```js
getData('from_db', function (result) {
  // 消耗时间M
});

getData('from_remote_api', function (result) {
  // 消耗时间为N
});
```

对比两者的时间总消耗，前者为 M+N，后者为 max(M,N)。

随着应用复杂性的增加，情景将会编程 M+N+....和 max(M,N,...)，同步与异步的优势将会凸显出来。另一方面，随着网站或应用不断膨胀，数据将会分不到多台服务器上，分布式将会式常态。分布也意味着 M 与 N 的值会线性增长，这也会放大异步和同步在性能方面的差异。为了让读者感知 M 和 N 具体有多昂贵，下表列出了从 CPU 以及缓存到网络的数据访问所需要的开销。

| I/O 类型     | 花费的 CPU 时钟周期 |
| ------------ | ------------------- |
| CPU 一级缓存 | 3                   |
| CPU 二级缓存 | 14                  |
| 内存         | 250                 |
| 硬盘         | 41000000            |
| 网络         | 240000000           |

这就是异步 I/O 在 Node 中如此盛行，甚至将其作为主要理念进行设计的原因。I/O 是昂贵的，分布式 I/O 是更加昂贵的。

只有后端能够快速响应资源，才能让前端体验变好。

### 3.1.2 资源分配

排除用户体验的因素，我们从资源分配的层面来分析一下异步 I/O 的必要性。我们知道计算机在发展过程中将组件进行了抽象，分为 I/O 设备和计算设备。

假设业务场景中有一组步步相关的任务需要完成，现在主流方法有以下两种：

- 单线程串行依次执行。
- 多线程并行完成。

如果创建多线程的开销小于并行执行，那么多线程的方式是首选。多线程的代价在于创建线程和执行期线程上下文切换的开销较大。另外，在复杂的业务中，多线程编程经常面临锁、状态同步的问题，这是多线程被诟病的主要原因。但是多线程在多核 CPU 上能够有效提升 CPU 的利用率，这个优势是毋庸置疑的。

单线程顺序执行任务的方式比较符合编程人员按照顺序思考的思维方式。它依然是最主流的编程方式，因为异步表达。但是串行执行的缺点在于性能，任意一个略慢的任务都会导致后续任务执行代码被阻塞。在计算机资源中，通常 I/O 与 CPU 计算之间是可以并行运行的。但是同步的编程模型导致的问题是，I/O 的进行会让后续任务等待，这造成资源不能被更好地利用。

操作系统将会 CPU 地时间片分配给其余进程，以公平而有效地利用资源，基于这一点，有的服务器提升响应能力，会通过启动多个工作进程来高效利用资源，结束所有任务所需要地时间将会较长。这种模式类似于加三倍服务器，达到占用更多资源来提升服务速度，它并没有真正改善问题。
