# 模块机制

---

JavaScript自诞生以来，曾经没有人拿它当成一门真正的编程语言，认为它不过是一种网页小脚本而已，在web 1.0时代，这种脚本语言在网络中主要有两个作用广为流传，一个是表单校验，另一个是网页特效。另一方面，由于仓促地被创造出来，所以它自身地各种缺陷也被各种编程人员广为诟病。知道web 2.0时代，前端工程师利用它大大提升了网页上地用户体验。在这个过程中，B/S应用展现出比C/S应用优越地地方。因此JavaScirpt被广泛重视起来。

在web 2.0 流行的过程中，各种前端库和框架被开发出来，他们最初用于兼容各个版本的浏览器，随后随着更多的用户需求在前端被实现，JavaScript也从表单校验迁到应用开发级别上。在这个过程中，它大致经历了工具类库、组件库、前端框架、前端应用的变迁。

```flow
st1=>start: 工具
（浏览器兼容）
st2=>start: 组件
（功能模块）
st3=>start: 框架
（功能模块组织）
e=>end: 应用
（业务模块组织）
st1->st2->st3->e
```

经历了常常的后天努力过程，JavaScript不断被类聚和抽象，以更好的组织业务逻辑。从另一个角度而言，它也道出了JavaScript先天就缺乏的一项功能：模块。

在其它高级语言中，Java有类文件，Python有`import`机制，Ruby有`require`，PHP有`include`和`require`。而JavaScript通过`<script>`标签引入代码的方式显得杂乱无章，语言自身毫无组织和约束能力。人们不得不用命名空间等方式认为约束代码，以求达到安全和易用的目的。

但是看起来凌乱的JavaScript编程现状并不代表社区没有进步，JavaScript的本地化编程之路一直在探索中。在Node出现之前，服务端JavaScript基本没有市场，与欣欣向荣的前端JavaScript相比，Rhino等后端JavaScript运行环境基本只是用于小工具，但是经历十多年发展后，社区也为JavaScript制定了响应的规范，其中CommonJS规范的提出算是最为重要的里程碑。

## 2.1 CommonJS 规范

CommonJS规范为JavaScript制定了一个美好的愿景——希望JavaScript能够在任何地方运行。

### 2.1.1 CommonJS的出发点

在JavaScript的发展历程中，它主要在浏览器前端发光发热。由于官方规范（ECMAScript)规范化的时间较早，规范涵盖的范畴较小。这些规范中包含语法、类型、上下文、表达式、声明、方法、对象等语言的基本要素。在实际应用中，JavaScript的表现能力取决于宿主环境的API支持程度。在web 1.0时代，只有对DOM、BOM的基本支持。随着web 2.0的推进，HTML5崭露头角，它将web 网页应用带进web 应用时代，在浏览器中出现了更多、更强大的API供JavaScript调用，这得感谢W3C组织对HTML5规范的推进以及各大浏览器厂商对规范的大力支持。但是，web在发展，浏览器出现了更多的标准API，这些过程发生在前端，后端JavaScript的规范却远远落后。对于JavaScript自身而言，他的规范依然是薄弱的，还有以下缺陷。

- **没有模块系统**
- **标准库较少**。ECMAScript仅定义了部分核心库，对于文件系统，I/O流等常见需求却没有标准的API。就HTML5的发展状况而言，W3C标准化在一定意义上就是在推进这个过程，但是它仅限于浏览器。
- **没有标准接口**。在JavaScript中，几乎没有定义过如web服务器或者数据库之类的标准统一接口。
- **缺乏包管理系统**。这导致JavaScript应用中基本没有自动浇在和安装依赖的能力。

CommonJS规范的提出，主要是为了弥补当前JavaScript没有标准的缺陷，以达到像python、Ruby和Java等具备开发大型应用的基础能力，而不是停留在小脚本程序的阶段。他们期望那些用CommonJS API写出的应用可以具备跨宿主环境执行的能力，这样不仅可以利用JavaScript开发富客户端应用，而且还可以编写以下应用。

- 服务端JavaScrip应用程序。
- 命令行工具。
- 桌面图形界面应用程序。
- 混合应用（Titanium和Adobe AIR等形式的应用）。

如今，CommonJS中的大部分规范虽然依旧是草案，但是已经初显成效，为JavaScript开发大型应用程序指明了一条非常棒的道路。目前，它依旧在成长中，这些规范涵盖了模块、二进制、Buffer、字符集、I/O流、进程环境、文件系统、套接字、单元测试、Web服务器网关接口、包管理等。

理论和实践总是相互影响和促进的，Node能以一种比较成熟的姿态出现，离不开CommonJS规范的影响。在服务器端，CommonJS能以一种寻常的姿态写进各个公司的项目代码中，离不开Node优异的表现。实现的优良表现离不开规范最初优秀的设计，规范因实现的推广而得以普及。

Node借助CommonJS的Modules规范实现了一套非常易用的模块系统，NPM对Packages规范的完好支持使得Node应用在开发过程中事半功倍。

### 2.1.2 CommonJS的模块规范

CommonJS对模块的定义十分简单，主要分为模块引用、模块定义和模块标识3个部分。

#### 1.模块引用

模块引用的示例代码如下：

```javascript
var math = require('math');
```

在CommonJS规范中，存在`require()`方法，这个方法接受模块标识，以此引入一个模块的API到当前上下文中。

#### 2. 模块定义

在模块中，上下文提供`require()`方法来引入外部模块。对应引入的功能，上下文提供了`exports`对象用于导出当前模块的方法或变量，并且它是唯一导出的出口。在模块中，还存在一个`Module`对象，它代表模块自身，而`exports`是`Module`的属性。在Node中，一个文件就是一个模块，将方法挂载在`exports`对象上作为属性即可定义导出的方式：

```javascript
// math.js
exports.add = function(){
  var sum = 0, i = 0, args = arguments, l = args.length;
  while(i<l){
    sum += args[i++];
  }
  return sum;
};
```

在另一个文件中，我们通过`require()`方法引入模块后，就能调用定义的属性和方法了：

```javascript
//program.js
var math = require('math');
exports.increment = function(val){
  return math.add(val,1);
};
```

#### 3. 模块标识

模块标识其实就是传递给`require()`方法的参数，它必须是符合小驼峰命名的字符串，或者以`.`、`..`开头的相对路径或绝对路径。它可以没有文件后缀`.js`。

模块的定义十分简单，接口也十分简洁。它的意义在于将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出功能以顺畅地连接上下游依赖。每个模块具有独立地空间，他们互不干扰，在引用时，也显得干净利落。

CommonJS构建地这套模块导出和引入机制使得用户完全不必考虑变量污染，命名空间等方案与之相比相形见绌。

## 2.2 Node的模块实现

Node在实现中并非完全按照规范实现的，而是对模块规范进行了一定的取舍，同时也增加了少许自身需要的特性。尽管规范中`exports`、`require`和`module`听起来十分简单，但是Node在实现它们过程中究竟经历了什么，这个过程需要知晓。

在Node中引入模块，需要经历如下三个步骤：

- （1）路径分析
- （2）文件定位
- （3）编译执行

Node中的模块分为两类：一类是Node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。

- 核心模块部分在Node的源代码编译过程中，编译进了二进制执行文件。在Node进程启动的时候，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤都可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。
- 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。

接下来我们展开详细的模块加载过程

### 2.2.1 优先从缓存加载

展开介绍路径分析和文件定位之前，我们需要知晓，与前端浏览器缓存静态脚本用于提高性能一样，Node对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的是，浏览器仅仅缓存文件，而Node缓存的是编译和执行之后的对象。

不论是核心模块还是文件模块，`require()`方法对相同模块的二次加载都一律采用缓存优先的方式，这是`第一级优先`的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。

### 2.2.2 路径分析和文件定位

因为标识符有几种形式，对于不同的标识符，模块的查找和定位有不同程度上的差异。

#### 1. 模块标识符分析

前面提到过，`require()`方法接收一个标识符作为参数。在Node实现中，正是基于这样一个标识符进行模块查找的。模块标识符在Node中主要分为以下几类。

- 核心模块，如`http`、`fs`、`path`等。
- `.`或`..`开始的相对路径文件模块。
- 以`/`开始的绝对路径文件模块。
- 非路径形式的文件模块，如自定义的`connect`模块。

##### 核心模块

核心模块的优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码，其加载过程最快。

如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的。如果自己编写了一个`http`用户模块，想要加载成功，必须选择一个不同的标识符或者使用路径的方式。

##### 路径形式的文件模块

以`.`、`..`和`/`开始的标识符，这里都被当作文件模块来处理。在分析路径模块时，`require()`方法会将路径转换为真实的路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载更快。

由于文件模块给Node指明了确切的文件位置，所以查找过程中可以节省大量时间，其加载速度慢于核心模块。

##### 自定义模块

自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能时一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。

在介绍自定义模块的查找方式之前，我们需要先介绍下`模块路径`这个概念。

模块路径是Node在定位文件模块的具体文件时指定的查找策略，具体表现为一个路径组成的数组。关于这个路径的生成规则，我们可以手动尝试一番。

- （1）创建`module_path.js`文件，其内容为`console.log(module.paths)`；
- （2）将其放到任意一个目录中然后执行 `node module_path.js`。

在Linux下，你可能得到的是这样一个数组输出：

```javascript
[
  '/home/jackson/research/node_modules',
  '/home/jackson/node_modules',
  '/home/node_modules',
  '/node_modules'
]
```

而在Windows下，也许是这样：

```javascript
[
  'c:\\nodejs\\node_modules',
  'c:\\node_modules'
]
```

可以看出，模块路径的生成规则：

- 当前目录下的`node_modules`目录
- 父目录下的`node_modules`目录
- 父目录的父目录下的`node_modules`目录
- 沿路径向上逐级递归，直到根目录下的`node_modules`目录。

它的生成方式与JavaScript的原型链或作用域链的查找方式十分类似。在加载过程中，Node会逐个尝试模块路径中的路径，直到找到目标文件为止。可以看出，当前文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度最慢的原因。

#### 2. 文件定位

从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块时的效率。

但在文件的定位过程中，还有一些细节需要注意，这主要包括文件扩展名的分析、目录和包的处理。

##### 文件扩展名分析

`require()`在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS模块规范也允许在标识符中不包括文件扩展名，在这种情况下，Node会按照`.js`、`.node`、`.json`的次序补足扩展名，依次尝试。

在尝试过程中，需要调用fs模块同步阻塞式地判断文件是否存在。因为Node是单线程地，所以这里是一个会引起性能问题地地方。小诀窍是：如果是`.node`和`.json`，在传递给`require()`的标识符中带上扩展名，会加快一点速度。另一个诀窍是：同步配合缓存，可以大幅度缓解Node单线程中阻塞式调用的缺陷。

##### 目录分析和包

在分析标识符过程中，`require()`通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找是经常会出现，此时Node会将目录当成一个包来处理。

在这个过程中，Node对CommonJS包规范进行了一定程度的支持。首先，Node在当前目录下查找`package.json`（CommonJS包规范定义的包描述文件），通过JSON.parse()解析出包描述对象，从中去除`main`属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。

而如果main属性指定的文件名错误，或者压根没有`package.json`文件，Node会将index当作默认文件名，然后依次检查`index.js`、`index.node`、`index.json`。

如果目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有找到目标文件，则会抛出查找失败的异常。

## 2.2.3 模块编译

在Node中，每个文件模块都是一个对象，它的定义如下：

```javascript
function Module(id, parent){
  this.id = id;
  this.exports = {};
  this.parent = parent;
  if(parent && parent.children){
    parent.children.push(this);
  }
  
  this.filename = null;
  this.loaded = false;
  this.children = [];
}
```

编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入的方法也有所不同：

- `.js`文件。通过fs模块同步读取文件后编译执行。
- `.node`文件。这时C/C++编写的扩展文件，通过`dlopen()`方法加载最后编译生成文件。
- `.json`文件。通过fs模块同步读取文件后，用`JSON.parse()`返回结果。
- 其余扩展名文件。它们都被当作称`.js`文件载入。

每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。

根据不同的文件扩展名，Node调用不同的读取方式，如`.json`文件的调用如下：

```javascript
// Native extension for .json
Module._extensions['.json'] = function(module, filename){
  var content = NativeModule.require('fs').readFileSync(filename, 'utf8');
  try{
    module.exports = JSON.parse(stripBOM(content));
  }catch (err) {
    err.message = filename + ': ' + err.message;
    throw err;
  }
};
```

其中